<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Pixelify Sans' rel='stylesheet'>
    <style>
        * {
            padding: 0;
            margin: 0;
            font-family: 'Pixelify Sans', 'Arial', sans-serif;
            background-color: black;
            color: white;
        }

        main {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            width: 80vw;
            height: 80vh;
            box-sizing: border-box;
            margin: 0;
            position: absolute;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            background-color: lightblue;
        }

        .hidden {
            display: none;
        }

        #header {
            position: absolute;
            top: 10px;
            width: 80vw;
            text-align: center;
            font-size: 24px;
            text-shadow: 1px 1px 1px pink, 0 0 1em pink, 0 0 0.1em pink;
        }

        #instructions {
            position: absolute;
            bottom: 15px;
            width: 80vw;
            text-align: center;
            font-size: 20px;

        }

        a {
            color: lightblue;
            text-decoration: none;
            text-shadow: 1px 1px 1px white, 0 0 1em white, 0 0 0.1em white;
        }

        a:visited {
            color: lightblue;
        }

        a:hover {
            color: rgb(150, 223, 248);
        }
    </style>
    <link rel="icon" href="icon.ico" type="image/x-icon">
    <title>Bicycle Game</title>
</head>

<body>
    <main>
        <div id="header">
            <h1>Love you Mrs Neo!!</h1>
        </div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="hidden">
            <img src="assets/cycle1.png" id="pf0">
            <img src="assets/cycle2.png" id="pf1">
            <img src="assets/cycle3.png" id="pf2">
            <img src="assets/cycle4.png" id="pf3">
            <img src="assets/apple.png" id="apple">
            <img src="assets/banana.png" id="banana">
            <img src="assets/trafficcone.png" id="cone">
            <img src="assets/floor.png" id="floor">
        </div>
        <div id="instructions">
            <p>Click <a href='instructions.html'>here</a> for game controls.</p>
            <p>Art by <a href='https://github.com/mynameisashllee'>@mynameisashllee</a>, code by <a
                    href='https://github.com/Cp-Youfy'>@Cp-Youfy</a></p>
        </div>
    </main>
    <script>
        // https://mathspp.com/blog/javascript-2d-scrolling-game-tutorial
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const frames = [
            document.getElementById('pf0'),
            document.getElementById('pf1'),
            document.getElementById('pf2'),
            document.getElementById('pf3'),
        ];

        var currentFrame = 0;
        var imagesLoaded = 0;
        const totalFrames = frames.length;
        var frameRate = 5;
        var frameCounter = 0;

        function checkAllImagesLoaded() {
            imagesLoaded++;
            if (imagesLoaded == totalFrames) {
                gameLoop();
            }
        }

        var gearState = 3; // default - affects gravity
        const gearToGravity = {
            1: 0.1,
            2: 0.15,
            3: 0.2,
        }
        var gravity = 0.4; // determines falling and jump height
        var speed = 3; // speed at which obstacles / background scroll

        // Defines the apple obstacle
        const oApple = {
            img: document.getElementById('apple'),
            // Dynamically update based on canvas size
            height: 0,
            width: 0,
        }

        // Defines the banana obstacle
        const oBanana = {
            img: document.getElementById('banana'),
            // Dynamically update based on canvas size
            height: 0,
            width: 0,
        }

        // Defines the traffic cone obstacle
        const oCone = {
            img: document.getElementById('cone'),
            // Dynamically update based on canvas size
            height: 0,
            width: 0,
        }

        const player = {
            height: 0,
            width: 0,
            x: 40,
            y: 0,
            vy: 0, // vertical velocity
            // State variables
            isJumping: true,
        }

        const floor = {
            img: document.getElementById('floor'),
            // Set params later dynamically
            height: 0,
            width: 0
        }

        function jump() {
            if (!player.isJumping) {
                player.vy = -8;
                gravity = gearToGravity[gearState];
                player.isJumping = true;
            }
        }

        function shiftGears(gearNum) {
            console.log(gearNum)
            if (gearNum === "1") {
                gearState = 1;
            }
            else if (gearNum === "2") {
                gearState = 2;
            }
            else if (gearNum === "3") {
                gearState = 3;
            }
            gravity = gearToGravity[gearState];
        }

        function brake() {
            // Increases gravity with each press
            gravity += 0.04;
        }

        var obstacles = [];
        const obstacleTypes = [oApple, oBanana, oCone];
        var nextObstacleGap = 0;
        var score = 0;
        var groundHeight = 0; // modify later based on floor height

        function updateParams() {
            // Increment the score (per frame)
            // Only when not in debug mode for legitimacy's sake
            // (haha who am I kidding just edit source code)
            if (!debugMode) ++score;

            // Cap the speed or it is kinda impossible to play
            if (speed <= 9) speed += 0.001;

            // Updates position of objects
            // Player
            if (player.isJumping) {
                player.vy += gravity;
                player.y += player.vy;

                // // Falling gravity should make more sense
                // if (player.vy > 0) {
                //     gravity = 0.5;
                // }

                // Check for ground collision
                if (player.y + player.height >= canvas.height - groundHeight) {
                    player.isJumping = false;
                    player.y = canvas.height - player.height - groundHeight;
                    gravity = gearToGravity[gearState];
                }
            }

            // Obstacle
            var len = obstacles.length;
            // If no obstacles exist or obstacle gap from right edge is large enough
            if (len === 0 || canvas.width - obstacles[len - 1].x >= nextObstacleGap) {
                if (obstacles[len - 1]?.img != oCone.img) {
                    // Pick an obstacle randomly first
                    var obstacleType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                } else {
                    // Prevent two cones from spawning consecutively
                    var obstacleType = obstacleTypes[Math.floor(Math.random() * (obstacleTypes.length - 1))];
                }
                var newObstacle = {
                    img: obstacleType.img,
                    width: obstacleType.width,
                    height: obstacleType.height,
                    x: canvas.width,
                    y: canvas.height - obstacleType.height - groundHeight,
                }
                obstacles.push(newObstacle);
                nextObstacleGap = (canvas.width + newObstacle.width) / 3 + Math.random() * 200;
                console.log(obstacles)
            }

            obstacles.forEach((obstacle) => { obstacle.x -= speed; }
            );

            // Removes passed obstacles
            obstacles = obstacles.filter((obstacle) => { return obstacle.x + obstacle.width >= 0; }
            )

            if (heldKeys['KeyD']) {
                // Allows continuous increase of gravity in braking
                brake();
            }
        }

        const pad = 10; // account for a smaller hitbox for smoother gameplay
        var debugMode = false; // pauses loss condition to test collisions
        var isColliding = false; // tracks collision for visual display
        var gameOver = false; // tracks game end state

        function checkCollisions() {
            // Check for obstacle-player collisions
            var obstacle = obstacles[0];
            if (
                // Player's bottom edge is below top edge of the obstacle
                player.y + player.height >= obstacle.y + pad
                // Player's top edge is above bottom edge of the obstacle
                && player.y <= obstacle.y + obstacle.height - pad
                // Player's right edge is beyond the left edge of the obstacle
                && player.x + player.width >= obstacle.x + pad
                // Player is not past the obstacle
                && player.x <= obstacle.x + obstacle.width - pad
            ) {
                isColliding = true;
                if (!debugMode) {
                    // Game loss
                    gameOver = true;
                }
            }
            else {
                isColliding = false;
            }
        }

        var drawHitbox = false;

        function drawBike() {
            // Draw the player
            if (drawHitbox) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }
            frameCounter++;
            if (frameCounter >= frameRate) {
                currentFrame = (currentFrame + 1) % totalFrames;
                frameCounter = 0;
            }
            ctx.drawImage(frames[currentFrame], player.x, player.y, player.width, player.height);
        }

        function drawObstacles() {
            obstacles.forEach((obstacle) => {
                if (drawHitbox) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(obstacle.x + pad, obstacle.y + pad, obstacle.width - pad * 2, obstacle.height - pad * 2);
                }

                ctx.drawImage(obstacle.img, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });
        }

        function drawBackground() {
            // Draw the floor
            ctx.drawImage(floor.img, 0, canvas.height - floor.height, canvas.width, floor.height);
        }

        function drawPrompts() {
            if (debugMode) {
                // Display text for debug mode
                ctx.fillStyle = "black";
                ctx.font = "24px Pixelify Sans";
                ctx.fillText("Debug Mode Enabled (Key M)", canvas.width - 350, 30);
                ctx.fillText("Colliding: " + isColliding.toString(), canvas.width - 190, 60);
                ctx.fillText("Speed: " + speed.toFixed(3), canvas.width - 200, 90);
            }

            ctx.fillStyle = "black";
            ctx.font = "30px Pixelify Sans";
            ctx.fillText("Score: " + score, 20, 40);
        }

        var theta = 0;
        const maxAngle = 359;

        async function wipeScreen() {
            // Wipes to game over
            ctx.save();

            // Set center of rotation
            ctx.translate(canvas.width / 2, canvas.height / 2);

            // Draws the wiping colour effect
            ctx.beginPath();
            ctx.moveTo(0, 0);
            // Measured from positive x-axis, in radians
            ctx.arc(0, 0, canvas.width * Math.sqrt(2), 0, theta * Math.PI / 180);
            ctx.closePath()

            ctx.fillStyle = "lightblue";
            ctx.fill();

            ctx.restore(); // Prevents stacking transforms
            theta += 10;

            if (theta <= maxAngle) {
                requestAnimationFrame(wipeScreen);
            } else {
                // Clears canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawEndScreen();
            }
        }

        async function endScreen() {
            requestAnimationFrame(wipeScreen);
        }

        var endScreenAnimationDone = false;
        function drawEndScreen() {
            // Draws the game over screen
            ctx.fillStyle = "red";
            ctx.font = "48px Pixelify Sans";
            ctx.textAlign = "center";
            ctx.fillText("Game over", canvas.width / 2, canvas.height / 2 - 5);
            ctx.fillStyle = "black";
            ctx.font = "36px Pixelify Sans";
            ctx.fillText("Final Score: " + score, canvas.width / 2, canvas.height / 2 + 45);
            ctx.fillText("Press R to restart", canvas.width / 2, canvas.height / 2 + 95);
            endScreenAnimationDone = true;
        }

        var isPaused = false;

        function gameLoop() {
            // Clears canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculations
            updateParams();
            checkCollisions();

            // Display
            drawBackground();
            drawBike();
            drawObstacles();
            drawPrompts();

            if (gameOver) {
                // Game over screen
                endScreen();
            }
            else {
                // Loop again
                if (!isPaused) requestAnimationFrame(gameLoop);
            }
        }

        function resizeCanvas() {
            // Scales the canvas upon first load
            canvas.width = window.innerWidth * 0.8;
            canvas.height = window.innerHeight * 0.8;

            // Scales objects accordingly
            player.height = canvas.height * 0.2;
            player.width = player.height * 1.4;
            player.y = canvas.height - player.height - 20;

            oApple.height = canvas.height * 0.20;
            oApple.width = oApple.height * 0.75;

            oBanana.height = canvas.height * 0.05;
            oBanana.width = oBanana.height * 2.5;

            oCone.height = canvas.height * 0.3;
            oCone.width = oCone.height * 0.7;

            floor.height = canvas.height * 0.4;
            floor.width = canvas.width;

            groundHeight = floor.height; // modify based on background
        }



        /* Main code */
        // Keydown events
        heldKeys = {} // for keys where continuous holding has to be detected

        document.addEventListener(
            "keydown", (event) => {
                if (event.code === "Space") jump();
                if (event.code === "Digit1" || event.code === "Digit2" || event.code === "Digit3") shiftGears(event.code.slice(-1));
                if (event.code === "KeyD" && player.isJumping) heldKeys[event.code] = true;
                if (event.code === "KeyH") drawHitbox = !drawHitbox;
                if (event.code === "KeyM") debugMode = !debugMode;
                if (event.code === "KeyP" && !gameOver) {
                    isPaused = !isPaused;
                    gameLoop();
                }
                if (event.code === "KeyR" && gameOver && endScreenAnimationDone) {
                    // Restart the game
                    ctx.textAlign = "left";
                    score = 0;
                    speed = 3;
                    gameOver = false;
                    isPaused = false;
                    endScreenAnimationDone = false;
                    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transformation matrix
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    obstacles = [];
                    theta = 0;
                    gameLoop();
                }
            },
        );

        document.addEventListener(
            "keyup", (event) => {
                heldKeys[event.code] = false;
            }
        )

        // Resizes canvas whenever the event is triggered
        // window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        frames.forEach(frame => {
            if (frame.complete) {
                checkAllImagesLoaded();
            } else {
                // Waits for the load event to finish executing, then check if all images were loaded
                frame.addEventListener('load', checkAllImagesLoaded);
            }

        });
    </script>
</body>

</html>