<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        main {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            width: 80vw;
            height: 80vh;
            box-sizing: border-box;
            margin: 0;
            position: absolute;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            background-color: lightblue;
        }

        .hidden {
            display: none;
        }

    </style>
    <link rel="icon" type="image/x-icon" href="bike_sample.gif">
    <title>Bicycle Demo</title>
</head>
<body>
    <main>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="hidden">
            <img src="assets/cycle1.png" id="pf0">
            <img src="assets/cycle2.png" id="pf1">
            <img src="assets/cycle3.png" id="pf2">
            <img src="assets/cycle4.png" id="pf3">
            <img src="assets/apple.png" id="apple">
        </div>
    </main>
    <script>
        // https://mathspp.com/blog/javascript-2d-scrolling-game-tutorial
        const canvas = document.getElementById('gameCanvas')
        const ctx = canvas.getContext('2d')

        const frames = [
            document.getElementById('pf0'),
            document.getElementById('pf1'),
            document.getElementById('pf2'),
            document.getElementById('pf3'),
        ];
        
        var currentFrame = 0;
        var imagesLoaded = 0;
        const totalFrames = frames.length;

        function checkAllImagesLoaded() {
            imagesLoaded++;
            if (imagesLoaded == totalFrames) {
                gameLoop();
            }
        }

        var gearState = 2; // default - affects gravity
        const gearToGravity = {
            1: 0.1,
            2: 0.2,
            3: 0.3,
        }
        var gravity = 0.4; // determines falling and jump height
        const groundHeight = 0; // modify based on background
        var speed = 3; // speed at which obstacles / background scroll

        // Defines the apple obstacle
        const oApple = {
            img: document.getElementById('apple'),
            // Dynamically update based on canvas size
            height: 0,
            width: 0,
        }

        const player = {
            height: 0,
            width: 0,
            x: 40,
            y: 0,
            vy: 0, // vertical velocity
            // State variables
            isJumping: true, 
        }

        function jump() {
            if (!player.isJumping) {
                player.vy = -8;
                gravity = gearToGravity[gearState]
                player.isJumping = true;
            }
        }

        function shiftGears(gearNum) {
            console.log(gearNum)
            if (gearNum === "1") {
                gearState = 1;
            }
            else if (gearNum === "2") {
                gearState = 2;
            }
            else if (gearNum === "3") {
                gearState = 3;
            }
            gravity = gearToGravity[gearState]
        }

        function brake() {
            // Increases gravity with each press
            gravity += 0.04;
        }

        var obstacles = []
        const obstacleTypes = [oApple]
        var nextObstacleGap = 0;

        function updateParams() {
            // Updates position of objects
            // Player
            if (player.isJumping) {
                player.vy += gravity;
                player.y += player.vy;

                // // Falling gravity should make more sense
                // if (player.vy > 0) {
                //     gravity = 0.5
                // }

                // Check for ground collision
                if (player.y + player.height >= canvas.height - groundHeight) {
                    player.isJumping = false;
                    player.y = canvas.height - player.height - groundHeight;
                    gravity = gearToGravity[gearState]
                }
            }

            // Obstacle
            var len = obstacles.length;
            // If no obstacles exist or obstacle gap from right edge is large enough
            if (len === 0 || canvas.width - obstacles[len-1].x >= nextObstacleGap) {
                // Pick an obstacle randomly first
                var obstacleType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                var newObstacle = {
                    img: obstacleType.img,
                    width: obstacleType.width,
                    height: obstacleType.height,
                    x: canvas.width,
                    y: canvas.height - obstacleType.height
                }
                obstacles.push(newObstacle);
                nextObstacleGap = (canvas.width + newObstacle.width) / 3 + Math.random() * 100;
                console.log(obstacles)
            }

            obstacles.forEach((obstacle) =>
            { obstacle.x -= speed; }
            );

            // Removes passed obstacles
            obstacles = obstacles.filter((obstacle) =>
                { return obstacle.x + obstacle.width >= 0; }
            )

            if (heldKeys['KeyD']) {
                // Allows continuous increase of gravity in braking
                brake()
            }
        }

        const pad = 10; // account for a smaller hitbox for smoother gameplay
        var debugMode = false; // pauses loss condition to test collisions
        var isColliding = false; // tracks collision for visual display
        var gameOver = false; // tracks game end state

        function checkCollisions() {
            // Check for obstacle-player collisions
            var obstacle = obstacles[0];
            if (
                // Player's bottom edge is below top edge of the obstacle
                player.y + player.height >= obstacle.y + pad
                // Player's top edge is above bottom edge of the obstacle
                && player.y <= obstacle.y + obstacle.height - pad
                // Player's right edge is beyond the left edge of the obstacle
                && player.x + player.width >= obstacle.x + pad
                // Player is not past the obstacle
                && player.x <= obstacle.x + obstacle.width - pad
            ) {
                isColliding = true;
                if (!debugMode) {
                    // Game loss
                    gameOver = true;
                }
            }
            else {
                isColliding = false;
            }
        }

        var drawHitbox = false;

        function drawBike() {
            // Draw the player
            if (drawHitbox) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            ctx.drawImage(frames[currentFrame], player.x, player.y, player.width, player.height);
            currentFrame = (currentFrame + 1) % totalFrames;
        }

        function drawObstacles() {
            obstacles.forEach((obstacle) =>
            { 
                if (drawHitbox) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(obstacle.x + pad, obstacle.y + pad, obstacle.width - pad * 2, obstacle.height - pad * 2);
                }

                ctx.drawImage(obstacle.img, obstacle.x, obstacle.y, obstacle.width, obstacle.height)
            });
        }

        function drawPrompts() {
            if (debugMode) {
                // Display text for debug mode
                ctx.fillStyle = "black";
                ctx.font = "24px Comic Sans MS";
                ctx.fillText("Debug Mode Enabled (Key M)", 0, 24);
                ctx.fillText("Colliding: " + isColliding.toString(), 0, 48)
            }
        }

        var theta = 0
        const maxAngle = 180;

        async function wipeScreen () {
            // Wipes to game over
            ctx.save();
            
            // Set center of rotation
            ctx.translate(canvas.width / 2, canvas.height / 2);
           
            // Draws the wiping colour effect
            ctx.beginPath();
            ctx.moveTo(0, 0);
            // Measured from positive x-axis, in radians
            ctx.arc(0, 0, canvas.width * Math.sqrt(2), 0, theta * Math.PI / 180)
            ctx.closePath()

            ctx.fillStyle = "lightpink";
            ctx.fill();

            ctx.restore(); // Prevents stacking transforms
            theta += 2

            if (theta <= maxAngle) {
                requestAnimationFrame(wipeScreen);
            } else {
                drawEndScreen();
            }
        }

        async function endScreen() {
            requestAnimationFrame(wipeScreen);
        }

        function drawEndScreen() {
            // Draws the game over screen
            ctx.fillStyle = "red";
            ctx.font = "48px Comic Sans MS";
            ctx.fillText("Game over", canvas.width / 2, canvas.height / 2 - 5);
        }

        function gameLoop() {
            // Clears canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculations
            updateParams();
            checkCollisions();

            // Display
            drawBike();
            drawObstacles();
            drawPrompts();

            if (gameOver) {
                // Game over screen
                endScreen();
            }
            else {
                // Loop again
                requestAnimationFrame(gameLoop)
            } 
        }

        function resizeCanvas() {
            // Scales the canvas upon first load
            canvas.width = window.innerWidth * 0.8;
            canvas.height = window.innerHeight * 0.8;

            // Scales objects accordingly
            player.height = canvas.height * 0.2;
            player.width = player.height;
            player.y = canvas.height - player.height - 20;

            oApple.height = canvas.height * 0.2;
            oApple.width = oApple.height * 0.6;
        }



        /* Main code */
        // Keydown events
        heldKeys = {} // for keys where continuous holding has to be detected

        document.addEventListener(
        "keydown", (event) => { 
            if (event.code === "Space") jump();
            if (event.code === "Digit1" || event.code === "Digit2" || event.code === "Digit3") shiftGears(event.code.slice(-1));
            if (event.code === "KeyD" && player.isJumping) heldKeys[event.code] = true;
            if (event.code === "KeyH") drawHitbox = !drawHitbox;
            if (event.code === "KeyM") debugMode = !debugMode;
        },
        );

        document.addEventListener(
            "keyup", (event) => {
                heldKeys[event.code] = false;
            }
        )

        // Resizes canvas whenever the event is triggered
        // window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        frames.forEach(frame => {
            if (frame.complete) {
                checkAllImagesLoaded();
            } else {
                // Waits for the load event to finish executing, then check if all images were loaded
                frame.addEventListener('load', checkAllImagesLoaded);
            }
        });
    </script>
</body>
</html>